/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/version/update": {
    put: operations["updateVersion"];
    parameters: {};
  };
  "/version": {
    get: operations["checkVersion"];
    parameters: {};
  };
  "/tuners": {
    get: operations["getTuners"];
    parameters: {};
  };
  "/status": {
    get: operations["getStatus"];
    parameters: {};
  };
  "/services": {
    get: operations["getServices"];
    parameters: {};
  };
  "/restart": {
    put: operations["restart"];
    parameters: {};
  };
  "/programs": {
    get: operations["getPrograms"];
    parameters: {};
  };
  "/log/stream": {
    get: operations["getLogStream"];
    parameters: {};
  };
  "/log": {
    get: operations["getLog"];
    parameters: {};
  };
  "/iptv/xmltv": {
    get: {
      parameters: {};
      responses: {
        /** OK */
        200: unknown;
        /** Unexpected Error */
        default: {
          schema: definitions["Error"];
        };
      };
    };
    parameters: {};
  };
  "/iptv/playlist": {
    get: {
      parameters: {};
      responses: {
        /** OK */
        200: unknown;
        /** Unexpected Error */
        default: {
          schema: definitions["Error"];
        };
      };
    };
    parameters: {};
  };
  "/iptv/lineup.json": {
    get: {
      parameters: {};
      responses: {
        /** OK */
        200: unknown;
        /** Unexpected Error */
        default: {
          schema: definitions["Error"];
        };
      };
    };
    parameters: {};
  };
  "/iptv/lineup_status.json": {
    get: {
      parameters: {};
      responses: {
        /** OK */
        200: unknown;
        /** Unexpected Error */
        default: {
          schema: definitions["Error"];
        };
      };
    };
    parameters: {};
  };
  "/iptv/discover.json": {
    get: {
      parameters: {};
      responses: {
        /** OK */
        200: unknown;
        /** Unexpected Error */
        default: {
          schema: definitions["Error"];
        };
      };
    };
    parameters: {};
  };
  "/events/stream": {
    get: operations["getEventsStream"];
    parameters: {};
  };
  "/events": {
    get: operations["getEvents"];
    parameters: {};
  };
  "/config/tuners": {
    get: operations["getTunersConfig"];
    put: operations["updateTunersConfig"];
    parameters: {};
  };
  "/config/server": {
    get: operations["getServerConfig"];
    put: operations["updateServerConfig"];
    parameters: {};
  };
  "/config/channels/scan": {
    /**
     * Entry rewriting specifications:
     * - The scan is performed on a range of channels of the specified type and the entries for those channels, if any, are saved in the configuration file.
     * - If the channel to be scanned is described in the configuration file and is enabled, the scan will not be performed for that channel and the entries described will remain intact. If you do not want to keep the entries, use the `refresh` option.
     * - All entries outside the channel range of the specified type will be deleted.
     * - All entries of a type other than the specified type will remain.
     *
     * About BS Subchannel Style:
     * - Only when scanning BS, you can specify the channel number in the subchannel style (e.g. BS01_0). To specify the channel number, use minSubCh and maxSubCh in addition to minCh and maxCh.
     * - The subchannel number parameters (minSubCh, maxSubCh) are used only if the type is BS and are ignored otherwise.
     * - Subchannel style scans scan in the following range:
     *     From `BS${minCh}_${minSubCh}` to `BS${maxCh}_${maxSubCh}`
     * - In the subchannel style, minCh and maxCh are zero padded to two digits. minSubCh and maxSubCh are not padded.
     * - BS "non" subchannel style scans and GR scans are basically the same. Note that if you scan the wrong channel range, the GR channel will be registered as BS and the BS channel will be registered as GR. This problem does not occur because CS scan uses a character string with `CS` added as a channel number prefix.
     */
    put: operations["channelScan"];
    parameters: {};
  };
  "/config/channels": {
    get: operations["getChannelsConfig"];
    put: operations["updateChannelsConfig"];
    parameters: {};
  };
  "/channels": {
    get: operations["getChannels"];
    parameters: {};
  };
  "/tuners/{index}/process": {
    get: operations["getTunerProcess"];
    delete: operations["killTunerProcess"];
    parameters: {
      path: {
        index: number;
      };
    };
  };
  "/tuners/{index}": {
    get: operations["getTuner"];
    parameters: {
      path: {
        index: number;
      };
    };
  };
  "/services/{id}/stream": {
    get: operations["getServiceStream"];
    parameters: {
      path: {
        id: number;
      };
      header: {
        "X-Mirakurun-Priority"?: number;
      };
      query: {
        decode?: number;
      };
    };
  };
  "/services/{id}/logo": {
    get: operations["getLogoImage"];
    parameters: {
      path: {
        id: number;
      };
    };
  };
  "/services/{id}": {
    get: operations["getService"];
    parameters: {
      path: {
        id: number;
      };
    };
  };
  "/programs/{id}/stream": {
    get: operations["getProgramStream"];
    parameters: {
      path: {
        id: number;
      };
      header: {
        "X-Mirakurun-Priority"?: number;
      };
      query: {
        decode?: number;
      };
    };
  };
  "/programs/{id}": {
    get: operations["getProgram"];
    parameters: {
      path: {
        id: number;
      };
    };
  };
  "/channels/{type}/{channel}/stream": {
    get: operations["getChannelStream"];
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
        channel: string;
      };
      header: {
        "X-Mirakurun-Priority"?: number;
      };
      query: {
        decode?: number;
      };
    };
  };
  "/channels/{type}/{channel}/services/{id}/stream": {
    get: operations["getServiceStreamByChannel"];
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
        channel: string;
        id: number;
      };
      header: {
        "X-Mirakurun-Priority"?: number;
      };
      query: {
        decode?: number;
      };
    };
  };
  "/channels/{type}/{channel}/services/{id}": {
    get: operations["getServiceByChannel"];
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
        channel: string;
        id: number;
      };
    };
  };
  "/channels/{type}/{channel}/services": {
    get: operations["getServicesByChannel"];
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
        channel: string;
      };
    };
  };
  "/channels/{type}/{channel}": {
    get: operations["getChannel"];
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
        channel: string;
      };
    };
  };
  "/channels/{type}": {
    get: operations["getChannelsByType"];
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
      };
    };
  };
}

export interface definitions {
  Error: {
    code?: number;
    reason?: string;
    errors?: definitions["ErrorOfOpenAPI"][];
  };
  ErrorOfOpenAPI: {
    errorCode?: string;
    message?: string;
    location?: string;
  };
  ProgramId: number;
  EventId: number;
  ServiceId: number;
  NetworkId: number;
  ServiceItemId: number;
  UnixtimeMS: number;
  Channel: {
    type: definitions["ChannelType"];
    channel: string;
    name?: string;
    satellite?: string;
    space?: number;
    freq?: number;
    /** @enum {string} */
    polarity?: "H" | "V";
    tsmfRelTs?: number;
    services?: definitions["Service"][];
  };
  /** @enum {string} */
  ChannelType: "GR" | "BS" | "CS" | "SKY";
  Service: {
    id: definitions["ServiceItemId"];
    serviceId: definitions["ServiceId"];
    networkId: definitions["NetworkId"];
    name: string;
    type: number;
    logoId?: number;
    hasLogoData?: boolean;
    remoteControlKeyId?: number;
    epgReady?: boolean;
    epgUpdatedAt?: definitions["UnixtimeMS"];
    channel?: definitions["Channel"];
  };
  Program: {
    id: definitions["ProgramId"];
    eventId: definitions["EventId"];
    serviceId: definitions["ServiceId"];
    networkId: definitions["NetworkId"];
    startAt: definitions["UnixtimeMS"];
    duration: number;
    isFree: boolean;
    name?: string;
    description?: string;
    genres?: definitions["ProgramGenre"][];
    video?: {
      type?: definitions["ProgramVideoType"];
      resolution?: definitions["ProgramVideoResolution"];
      streamContent?: number;
      componentType?: number;
    };
    audios?: {
      componentType?: number;
      componentTag?: number;
      isMain?: boolean;
      samplingRate?: definitions["ProgramAudioSamplingRate"];
      langs?: (
        | "jpn"
        | "eng"
        | "deu"
        | "fra"
        | "ita"
        | "rus"
        | "zho"
        | "kor"
        | "spa"
        | "etc"
      )[];
    }[];
    extended?: { [key: string]: unknown };
    relatedItems?: definitions["RelatedItem"][];
    series?: {
      id?: number;
      repeat?: number;
      pattern?: definitions["ProgramPattern"];
      expiresAt?: definitions["UnixtimeMS"];
      episode?: definitions["ProgramEpisodeNumber"];
      lastEpisode?: definitions["ProgramEpisodeNumber"];
      name?: string;
    };
  };
  ProgramGenre: {
    lv1?: number;
    lv2?: number;
    un1?: number;
    un2?: number;
  };
  /** @enum {string} */
  ProgramVideoType: "mpeg2" | "h.264" | "h.265";
  /** @enum {string} */
  ProgramVideoResolution:
    | "240p"
    | "480i"
    | "480p"
    | "720p"
    | "1080i"
    | "1080p"
    | "2160p"
    | "4320p";
  /** @enum {integer} */
  ProgramAudioSamplingRate: 16000 | 22050 | 24000 | 32000 | 44100 | 48000;
  ProgramPattern: number;
  ProgramEpisodeNumber: number;
  RelatedItem: {
    /** @enum {string} */
    type?: "shared" | "relay" | "movement";
    networkId?: number;
    serviceId?: number;
    eventId?: number;
  };
  TunerDevice: {
    index: number;
    name: string;
    types: definitions["ChannelType"][];
    command: string;
    pid: number;
    users: definitions["TunerUser"][];
    isAvailable: boolean;
    isRemote?: boolean;
    isFree: boolean;
    isUsing: boolean;
    isFault: boolean;
  };
  TunerUser: {
    id: string;
    priority: number;
    agent?: string;
    url?: string;
    disableDecoder?: boolean;
    streamSetting?: {
      channel: definitions["ConfigChannelsItem"];
      networkId?: number;
      serviceId?: number;
      eventId?: number;
      noProvide?: boolean;
      parseNIT?: boolean;
      parseSDT?: boolean;
      parseEIT?: boolean;
    };
    streamInfo?: {
      [key: string]: {
        packet: number;
        drop: number;
      };
    };
  };
  TunerProcess: {
    pid: number;
  };
  Event: {
    resource: definitions["EventResource"];
    type: definitions["EventType"];
    data: { [key: string]: unknown };
    time: definitions["UnixtimeMS"];
  };
  /** @enum {string} */
  EventResource: "program" | "service" | "tuner";
  /** @enum {string} */
  EventType: "create" | "update" | "remove";
  ConfigServer: {
    path?: string;
    port?: number;
    hostname?: string;
    disableIPv6?: boolean;
    logLevel?: number;
    maxLogHistory?: number;
    maxBufferBytesBeforeReady?: number;
    eventEndTimeout?: number;
    programGCInterval?: number;
    epgGatheringInterval?: number;
    epgRetrievalTime?: number;
    logoDataInterval?: number;
    disableEITParsing?: boolean;
    disableWebUI?: boolean;
    allowIPv4CidrRanges?: string[];
    allowIPv6CidrRanges?: string[];
  };
  ConfigTuners: definitions["ConfigTunersItem"][];
  ConfigTunersItem: {
    name: string;
    types: definitions["ChannelType"][];
    command?: string;
    dvbDevicePath?: string;
    remoteMirakurunHost?: string;
    remoteMirakurunPort?: number;
    remoteMirakurunDecoder?: boolean;
    decoder?: string;
    isDisabled?: boolean;
  };
  ConfigChannels: definitions["ConfigChannelsItem"][];
  ConfigChannelsItem: {
    name: string;
    type: definitions["ChannelType"];
    channel: string;
    serviceId?: definitions["ServiceId"];
    satellite?: string;
    space?: number;
    freq?: number;
    /** @enum {string} */
    polarity?: "H" | "V";
    isDisabled?: boolean;
  };
  Version: {
    current?: string;
    latest?: string;
  };
  Status: {
    time?: number;
    version?: string;
    process?: {
      arch?: string;
      platform?: string;
      versions?: { [key: string]: unknown };
      env?: { [key: string]: unknown };
      pid?: number;
      memoryUsage?: {
        rss?: number;
        heapTotal?: number;
        heapUsed?: number;
      };
    };
    epg?: {
      gatheringNetworks?: definitions["NetworkId"][];
      storedEvents?: number;
    };
    rpcCount?: number;
    streamCount?: {
      tunerDevice?: number;
      tsFilter?: number;
      decoder?: number;
    };
    errorCount?: {
      uncaughtException?: number;
      unhandledRejection?: number;
      bufferOverflow?: number;
      tunerDeviceRespawn?: number;
      decoderRespawn?: number;
    };
    timerAccuracy?: {
      last?: number;
      m1?: {
        avg?: number;
        min?: number;
        max?: number;
      };
      m5?: {
        avg?: number;
        min?: number;
        max?: number;
      };
      m15?: {
        avg?: number;
        min?: number;
        max?: number;
      };
    };
  };
}

export interface operations {
  updateVersion: {
    parameters: {
      query: {
        force?: boolean;
      };
    };
    responses: {
      /** Accepted */
      202: unknown;
      /** Update Nothing */
      409: {
        schema: definitions["Error"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  checkVersion: {
    parameters: {};
    responses: {
      /** OK */
      200: {
        schema: definitions["Version"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getTuners: {
    parameters: {};
    responses: {
      /** OK */
      200: {
        schema: definitions["TunerDevice"][];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getStatus: {
    parameters: {};
    responses: {
      /** OK */
      200: {
        schema: definitions["Status"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getServices: {
    parameters: {
      query: {
        serviceId?: number;
        networkId?: number;
        name?: string;
        type?: number;
        "channel.type"?: "GR" | "BS" | "CS" | "SKY";
        "channel.channel"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["Service"][];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  restart: {
    parameters: {};
    responses: {
      /** Accepted */
      202: unknown;
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getPrograms: {
    parameters: {
      query: {
        networkId?: number;
        serviceId?: number;
        eventId?: number;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["Program"][];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getLogStream: {
    parameters: {};
    responses: {
      /** OK */
      200: unknown;
      /** Unexpected Error */
      default: unknown;
    };
  };
  getLog: {
    parameters: {};
    responses: {
      /** OK */
      200: unknown;
      /** Unexpected Error */
      default: unknown;
    };
  };
  getEventsStream: {
    parameters: {
      query: {
        resource?: "program" | "service" | "tuner";
        type?: "create" | "update" | "remove";
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["Event"][];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getEvents: {
    parameters: {};
    responses: {
      /** OK */
      200: {
        schema: definitions["Event"][];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getTunersConfig: {
    parameters: {};
    responses: {
      /** OK */
      200: {
        schema: definitions["ConfigTuners"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  updateTunersConfig: {
    parameters: {
      body: {
        body?: definitions["ConfigTuners"];
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["ConfigTuners"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getServerConfig: {
    parameters: {};
    responses: {
      /** OK */
      200: {
        schema: definitions["ConfigServer"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  updateServerConfig: {
    parameters: {
      body: {
        body?: definitions["ConfigServer"];
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["ConfigServer"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /**
   * Entry rewriting specifications:
   * - The scan is performed on a range of channels of the specified type and the entries for those channels, if any, are saved in the configuration file.
   * - If the channel to be scanned is described in the configuration file and is enabled, the scan will not be performed for that channel and the entries described will remain intact. If you do not want to keep the entries, use the `refresh` option.
   * - All entries outside the channel range of the specified type will be deleted.
   * - All entries of a type other than the specified type will remain.
   *
   * About BS Subchannel Style:
   * - Only when scanning BS, you can specify the channel number in the subchannel style (e.g. BS01_0). To specify the channel number, use minSubCh and maxSubCh in addition to minCh and maxCh.
   * - The subchannel number parameters (minSubCh, maxSubCh) are used only if the type is BS and are ignored otherwise.
   * - Subchannel style scans scan in the following range:
   *     From `BS${minCh}_${minSubCh}` to `BS${maxCh}_${maxSubCh}`
   * - In the subchannel style, minCh and maxCh are zero padded to two digits. minSubCh and maxSubCh are not padded.
   * - BS "non" subchannel style scans and GR scans are basically the same. Note that if you scan the wrong channel range, the GR channel will be registered as BS and the BS channel will be registered as GR. This problem does not occur because CS scan uses a character string with `CS` added as a channel number prefix.
   */
  channelScan: {
    parameters: {
      query: {
        /** dry run. If `true`, the scanned result will not be saved. */
        dryRun?: boolean;
        /** Specifies the channel type to scan. */
        type?: "GR" | "BS" | "CS";
        /** Specifies the minimum number of channel numbers to scan. */
        minCh?: number;
        /** Specifies the maximum number of channel numbers to scan. */
        maxCh?: number;
        /** Specifies the minimum number of subchannel numbers to scan. This parameter is only used if the type is `BS` and the bs_subch_style is `true`. */
        minSubCh?: number;
        /** Specifies the maximum number of subchannel numbers to scan. This parameter is only used if the type is `BS` and the bs_subch_style is `true`. */
        maxSubCh?: number;
        /** Specify true to specify the channel in the subchannel style. Only used for BS scans. (e.g. BS01_0) */
        useSubCh?: boolean;
        /**
         * To specify the service explictly, use the `Service` mode.
         *
         * _Default value (GR)_: Channel
         * _Default value (BS/CS)_: Service
         */
        scanMode?: "Channel" | "Service";
        /**
         * If `true`, set disable on add channel.
         *
         * _Default value (GR)_: false
         * _Default value (BS/CS)_: true
         */
        setDisabledOnAdd?: boolean;
        /**
         * If `true`, update the existing settings without inheriting them.
         * However, non-scanned types of channels will always be inherited.
         */
        refresh?: boolean;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Already Scanning */
      409: {
        schema: definitions["Error"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getChannelsConfig: {
    parameters: {};
    responses: {
      /** OK */
      200: {
        schema: definitions["ConfigChannels"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  updateChannelsConfig: {
    parameters: {
      body: {
        body?: definitions["ConfigChannels"];
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["ConfigChannels"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getChannels: {
    parameters: {
      query: {
        type?: "GR" | "BS" | "CS" | "SKY";
        channel?: string;
        name?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["Channel"][];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getTunerProcess: {
    parameters: {
      path: {
        index: number;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["TunerProcess"];
      };
      /** Not Found */
      404: {
        schema: definitions["Error"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  killTunerProcess: {
    parameters: {
      path: {
        index: number;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: {
          pid?: unknown;
        };
      };
      /** Not Found */
      404: {
        schema: definitions["Error"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getTuner: {
    parameters: {
      path: {
        index: number;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["TunerDevice"];
      };
      /** Not Found */
      404: {
        schema: definitions["Error"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getServiceStream: {
    parameters: {
      path: {
        id: number;
      };
      header: {
        "X-Mirakurun-Priority"?: number;
      };
      query: {
        decode?: number;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Not Found */
      404: unknown;
      /** Tuner Resource Unavailable */
      503: unknown;
      /** Unexpected Error */
      default: unknown;
    };
  };
  getLogoImage: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Not Found */
      404: unknown;
      /** Logo Data Unavailable */
      503: unknown;
      /** Unexpected Error */
      default: unknown;
    };
  };
  getService: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["Service"];
      };
      /** Not Found */
      404: {
        schema: definitions["Error"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getProgramStream: {
    parameters: {
      path: {
        id: number;
      };
      header: {
        "X-Mirakurun-Priority"?: number;
      };
      query: {
        decode?: number;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Not Found */
      404: unknown;
      /** Tuner Resource Unavailable */
      503: unknown;
      /** Unexpected Error */
      default: unknown;
    };
  };
  getProgram: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["Program"];
      };
      /** Not Found */
      404: {
        schema: definitions["Error"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getChannelStream: {
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
        channel: string;
      };
      header: {
        "X-Mirakurun-Priority"?: number;
      };
      query: {
        decode?: number;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Not Found */
      404: unknown;
      /** Tuner Resource Unavailable */
      503: unknown;
      /** Unexpected Error */
      default: unknown;
    };
  };
  getServiceStreamByChannel: {
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
        channel: string;
        id: number;
      };
      header: {
        "X-Mirakurun-Priority"?: number;
      };
      query: {
        decode?: number;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Not Found */
      404: unknown;
      /** Tuner Resource Unavailable */
      503: unknown;
      /** Unexpected Error */
      default: unknown;
    };
  };
  getServiceByChannel: {
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
        channel: string;
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["Service"][];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getServicesByChannel: {
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
        channel: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["Service"][];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getChannel: {
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
        channel: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["Channel"];
      };
      /** Not Found */
      404: {
        schema: definitions["Error"];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  getChannelsByType: {
    parameters: {
      path: {
        type: "GR" | "BS" | "CS" | "SKY";
      };
      query: {
        channel?: string;
        name?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions["Channel"][];
      };
      /** Unexpected Error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
}

export interface external {}
